<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Language Coding Challenges</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: #2c3e50;
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }

        .language-selector, .level-selector {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .selector-label {
            font-weight: 600;
            color: #2c3e50;
            margin-right: 10px;
        }

        .lang-btn, .level-btn {
            padding: 8px 16px;
            border: 2px solid #3498db;
            background: white;
            color: #3498db;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .lang-btn.active, .level-btn.active {
            background: #3498db;
            color: white;
        }

        .lang-btn:hover, .level-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.3);
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #ecf0f1;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 30px;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2ecc71);
            width: 0%;
            transition: width 0.3s ease;
        }

        .challenge-card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.1);
            border-left: 5px solid #3498db;
        }

        .challenge-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .challenge-title {
            font-size: 1.5em;
            color: #2c3e50;
            font-weight: 600;
        }

        .difficulty {
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.9em;
            font-weight: 500;
        }

        .beginner { background: #2ecc71; color: white; }
        .intermediate { background: #f39c12; color: white; }
        .hard { background: #e74c3c; color: white; }
        .expert { background: #8e44ad; color: white; }

        .problem-statement {
            line-height: 1.6;
            margin-bottom: 20px;
            color: #34495e;
        }

        .code-block {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 10px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            overflow-x: auto;
        }

        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-top: 20px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            text-decoration: none;
            display: inline-block;
        }

        .btn-primary {
            background: #3498db;
            color: white;
        }

        .btn-secondary {
            background: #95a5a6;
            color: white;
        }

        .btn-success {
            background: #2ecc71;
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .hidden {
            display: none;
        }

        .hint, .solution {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 15px;
            margin-top: 15px;
        }

        .hint {
            border-left: 4px solid #f39c12;
        }

        .solution {
            border-left: 4px solid #2ecc71;
        }

        .test-cases {
            background: #e8f4f8;
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
        }

        .stats {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-bottom: 30px;
            background: rgba(255, 255, 255, 0.7);
            padding: 20px;
            border-radius: 15px;
        }

        .stat-item {
            text-align: center;
        }

        .stat-number {
            font-size: 2em;
            font-weight: bold;
            color: #3498db;
        }

        .stat-label {
            color: #7f8c8d;
            font-size: 0.9em;
        }

        .challenge-controls {
            text-align: center;
            margin-top: 30px;
        }

        .no-challenges {
            text-align: center;
            padding: 40px;
            color: #7f8c8d;
            font-size: 1.1em;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🚀 Multi-Language Coding Challenges</h1>
            <p>Progressive difficulty • Beginner to Expert</p>
        </div>

        <div class="controls">
            <div class="language-selector">
                <span class="selector-label">Language:</span>
                <button class="lang-btn active" data-lang="cpp">C++</button>
                <button class="lang-btn" data-lang="python">Python</button>
                <button class="lang-btn" data-lang="java">Java</button>
            </div>
            
            <div class="level-selector">
                <span class="selector-label">Level:</span>
                <button class="level-btn" data-level="beginner">Beginner</button>
                <button class="level-btn active" data-level="intermediate">Intermediate</button>
                <button class="level-btn" data-level="hard">Hard</button>
                <button class="level-btn" data-level="expert">Expert</button>
            </div>
        </div>

        <div class="stats">
            <div class="stat-item">
                <div class="stat-number" id="solved-count">0</div>
                <div class="stat-label">Solved</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="total-count">0</div>
                <div class="stat-label">Available</div>
            </div>
            <div class="stat-item">
                <div class="stat-number" id="hints-used">0</div>
                <div class="stat-label">Hints Used</div>
            </div>
        </div>

        <div class="progress-bar">
            <div class="progress-fill" id="progress"></div>
        </div>

        <div id="challenges-container">
            <!-- Challenges will be inserted here -->
        </div>

        <div class="challenge-controls">
            <button class="btn btn-primary" onclick="loadChallenges()">Load Challenges</button>
        </div>
    </div>

    <script>
        const challenges = {
            beginner: [
                {
                    id: 'b1',
                    title: "Two Sum",
                    difficulty: "beginner",
                    problem: `Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.

You may assume that each input would have exactly one solution, and you may not use the same element twice.

Example:
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].`,
                    testCases: `Input: nums = [2,7,11,15], target = 9
Output: [0,1]

Input: nums = [3,2,4], target = 6
Output: [1,2]

Input: nums = [3,3], target = 6
Output: [0,1]`,
                    hint: "Use a hash map to store each number and its index. For each element, check if target - element exists in the map.",
                    solutions: {
                        cpp: `vector<int> twoSum(vector<int>& nums, int target) {
    unordered_map<int, int> numMap;
    
    for (int i = 0; i < nums.size(); i++) {
        int complement = target - nums[i];
        
        if (numMap.find(complement) != numMap.end()) {
            return {numMap[complement], i};
        }
        
        numMap[nums[i]] = i;
    }
    
    return {};
}`,
                        python: `def twoSum(nums, target):
    num_map = {}
    
    for i, num in enumerate(nums):
        complement = target - num
        
        if complement in num_map:
            return [num_map[complement], i]
        
        num_map[num] = i
    
    return []`,
                        java: `public int[] twoSum(int[] nums, int target) {
    Map<Integer, Integer> numMap = new HashMap<>();
    
    for (int i = 0; i < nums.length; i++) {
        int complement = target - nums[i];
        
        if (numMap.containsKey(complement)) {
            return new int[]{numMap.get(complement), i};
        }
        
        numMap.put(nums[i], i);
    }
    
    return new int[0];
}`
                    }
                },
                {
                    id: 'b2',
                    title: "Valid Parentheses",
                    difficulty: "beginner",
                    problem: `Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.

An input string is valid if:
1. Open brackets must be closed by the same type of brackets.
2. Open brackets must be closed in the correct order.

Example:
Input: s = "()[]{}"
Output: true

Input: s = "([)]"
Output: false`,
                    testCases: `Input: s = "()"
Output: true

Input: s = "()[]{}"
Output: true

Input: s = "([)]"
Output: false`,
                    hint: "Use a stack to keep track of opening brackets. When you see a closing bracket, check if it matches the most recent opening bracket.",
                    solutions: {
                        cpp: `bool isValid(string s) {
    stack<char> st;
    unordered_map<char, char> mapping = {
        {')', '('}, {'}', '{'}, {']', '['}
    };
    
    for (char c : s) {
        if (mapping.find(c) != mapping.end()) {
            if (st.empty() || st.top() != mapping[c]) {
                return false;
            }
            st.pop();
        } else {
            st.push(c);
        }
    }
    
    return st.empty();
}`,
                        python: `def isValid(s):
    stack = []
    mapping = {')': '(', '}': '{', ']': '['}
    
    for char in s:
        if char in mapping:
            if not stack or stack.pop() != mapping[char]:
                return False
        else:
            stack.append(char)
    
    return not stack`,
                        java: `public boolean isValid(String s) {
    Stack<Character> stack = new Stack<>();
    Map<Character, Character> mapping = new HashMap<>();
    mapping.put(')', '(');
    mapping.put('}', '{');
    mapping.put(']', '[');
    
    for (char c : s.toCharArray()) {
        if (mapping.containsKey(c)) {
            if (stack.isEmpty() || stack.pop() != mapping.get(c)) {
                return false;
            }
        } else {
            stack.push(c);
        }
    }
    
    return stack.isEmpty();
}`
                    }
                },
                {
                    id: 'b3',
                    title: "Palindrome Number",
                    difficulty: "beginner",
                    problem: `Given an integer x, return true if x is palindrome integer.

An integer is a palindrome when it reads the same backward as forward.

Example:
Input: x = 121
Output: true

Input: x = -121
Output: false
Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.`,
                    testCases: `Input: x = 121
Output: true

Input: x = -121
Output: false

Input: x = 10
Output: false`,
                    hint: "You can reverse the number and compare it with the original, or reverse only half the number to save space.",
                    solutions: {
                        cpp: `bool isPalindrome(int x) {
    if (x < 0) return false;
    
    long long reversed = 0;
    int original = x;
    
    while (x > 0) {
        reversed = reversed * 10 + x % 10;
        x /= 10;
    }
    
    return original == reversed;
}`,
                        python: `def isPalindrome(x):
    if x < 0:
        return False
    
    reversed_num = 0
    original = x
    
    while x > 0:
        reversed_num = reversed_num * 10 + x % 10
        x //= 10
    
    return original == reversed_num`,
                        java: `public boolean isPalindrome(int x) {
    if (x < 0) return false;
    
    long reversed = 0;
    int original = x;
    
    while (x > 0) {
        reversed = reversed * 10 + x % 10;
        x /= 10;
    }
    
    return original == reversed;
}`
                    }
                }
            ],
            intermediate: [
                {
                    id: 'i1',
                    title: "Binary Tree Level Order Traversal",
                    difficulty: "intermediate",
                    problem: `Given the root of a binary tree, return the level order traversal of its nodes' values (i.e., from left to right, level by level).

For example, given the binary tree [3,9,20,null,null,15,7]:
- Level 0: [3]
- Level 1: [9, 20]
- Level 2: [15, 7]

Return: [[3], [9, 20], [15, 7]]`,
                    testCases: `Input: root = [3,9,20,null,null,15,7]
Output: [[3],[9,20],[15,7]]

Input: root = [1]
Output: [[1]]

Input: root = []
Output: []`,
                    hint: "Use a queue (BFS) to traverse level by level. Keep track of the current level size to group nodes properly.",
                    solutions: {
                        cpp: `vector<vector<int>> levelOrder(TreeNode* root) {
    if (!root) return {};
    
    vector<vector<int>> result;
    queue<TreeNode*> q;
    q.push(root);
    
    while (!q.empty()) {
        int levelSize = q.size();
        vector<int> currentLevel;
        
        for (int i = 0; i < levelSize; i++) {
            TreeNode* node = q.front();
            q.pop();
            currentLevel.push_back(node->val);
            
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
        
        result.push_back(currentLevel);
    }
    
    return result;
}`,
                        python: `def levelOrder(root):
    if not root:
        return []
    
    result = []
    queue = [root]
    
    while queue:
        level_size = len(queue)
        current_level = []
        
        for _ in range(level_size):
            node = queue.pop(0)
            current_level.append(node.val)
            
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)
        
        result.append(current_level)
    
    return result`,
                        java: `public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> result = new ArrayList<>();
    if (root == null) return result;
    
    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    
    while (!queue.isEmpty()) {
        int levelSize = queue.size();
        List<Integer> currentLevel = new ArrayList<>();
        
        for (int i = 0; i < levelSize; i++) {
            TreeNode node = queue.poll();
            currentLevel.add(node.val);
            
            if (node.left != null) queue.offer(node.left);
            if (node.right != null) queue.offer(node.right);
        }
        
        result.add(currentLevel);
    }
    
    return result;
}`
                    }
                },
                {
                    id: 'i2',
                    title: "Longest Substring Without Repeating Characters",
                    difficulty: "intermediate",
                    problem: `Given a string s, find the length of the longest substring without repeating characters.

Examples:
- "abcabcbb" → 3 (substring "abc")
- "bbbbb" → 1 (substring "b")
- "pwwkew" → 3 (substring "wke")`,
                    testCases: `Input: s = "abcabcbb"
Output: 3

Input: s = "bbbbb"
Output: 1

Input: s = "pwwkew"
Output: 3`,
                    hint: "Use sliding window technique with two pointers. Keep track of character positions using a hash map.",
                    solutions: {
                        cpp: `int lengthOfLongestSubstring(string s) {
    unordered_map<char, int> charIndex;
    int maxLength = 0;
    int left = 0;
    
    for (int right = 0; right < s.length(); right++) {
        if (charIndex.find(s[right]) != charIndex.end() && 
            charIndex[s[right]] >= left) {
            left = charIndex[s[right]] + 1;
        }
        
        charIndex[s[right]] = right;
        maxLength = max(maxLength, right - left + 1);
    }
    
    return maxLength;
}`,
                        python: `def lengthOfLongestSubstring(s):
    char_index = {}
    max_length = 0
    left = 0
    
    for right, char in enumerate(s):
        if char in char_index and char_index[char] >= left:
            left = char_index[char] + 1
        
        char_index[char] = right
        max_length = max(max_length, right - left + 1)
    
    return max_length`,
                        java: `public int lengthOfLongestSubstring(String s) {
    Map<Character, Integer> charIndex = new HashMap<>();
    int maxLength = 0;
    int left = 0;
    
    for (int right = 0; right < s.length(); right++) {
        char c = s.charAt(right);
        
        if (charIndex.containsKey(c) && charIndex.get(c) >= left) {
            left = charIndex.get(c) + 1;
        }
        
        charIndex.put(c, right);
        maxLength = Math.max(maxLength, right - left + 1);
    }
    
    return maxLength;
}`
                    }
                }
            ],
            hard: [
                {
                    id: 'h1',
                    title: "Merge k Sorted Lists",
                    difficulty: "hard",
                    problem: `You are given an array of k linked-lists, each sorted in ascending order. Merge all the linked-lists into one sorted linked-list and return it.

Example:
Input: lists = [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]

Can you solve it with O(n log k) time complexity?`,
                    testCases: `Input: lists = [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]

Input: lists = []
Output: []`,
                    hint: "Use a min-heap (priority queue) to always get the smallest element from all lists. Alternatively, use divide and conquer.",
                    solutions: {
                        cpp: `ListNode* mergeKLists(vector<ListNode*>& lists) {
    auto compare = [](ListNode* a, ListNode* b) {
        return a->val > b->val;
    };
    
    priority_queue<ListNode*, vector<ListNode*>, decltype(compare)> pq(compare);
    
    for (ListNode* list : lists) {
        if (list) pq.push(list);
    }
    
    ListNode dummy(0);
    ListNode* current = &dummy;
    
    while (!pq.empty()) {
        ListNode* smallest = pq.top();
        pq.pop();
        
        current->next = smallest;
        current = current->next;
        
        if (smallest->next) {
            pq.push(smallest->next);
        }
    }
    
    return dummy.next;
}`,
                        python: `import heapq

def mergeKLists(lists):
    heap = []
    
    for i, node in enumerate(lists):
        if node:
            heapq.heappush(heap, (node.val, i, node))
    
    dummy = ListNode(0)
    current = dummy
    
    while heap:
        val, i, node = heapq.heappop(heap)
        current.next = node
        current = current.next
        
        if node.next:
            heapq.heappush(heap, (node.next.val, i, node.next))
    
    return dummy.next`,
                        java: `public ListNode mergeKLists(ListNode[] lists) {
    PriorityQueue<ListNode> pq = new PriorityQueue<>((a, b) -> a.val - b.val);
    
    for (ListNode list : lists) {
        if (list != null) {
            pq.offer(list);
        }
    }
    
    ListNode dummy = new ListNode(0);
    ListNode current = dummy;
    
    while (!pq.isEmpty()) {
        ListNode smallest = pq.poll();
        current.next = smallest;
        current = current.next;
        
        if (smallest.next != null) {
            pq.offer(smallest.next);
        }
    }
    
    return dummy.next;
}`
                    }
                },
                {
                    id: 'h2',
                    title: "Maximum Sliding Window",
                    difficulty: "hard",
                    problem: `Given an array of integers nums and a sliding window of size k, return the maximum value in each sliding window as it moves from left to right.

Example:
Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
Output: [3,3,5,5,6,7]

Window positions:
[1  3  -1] -3  5  3  6  7 → max = 3
 1 [3  -1  -3] 5  3  6  7 → max = 3`,
                    testCases: `Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
Output: [3,3,5,5,6,7]

Input: nums = [1], k = 1
Output: [1]`,
                    hint: "Use a deque to maintain indices of elements in decreasing order. The front always contains the index of maximum element.",
                    solutions: {
                        cpp: `vector<int> maxSlidingWindow(vector<int>& nums, int k) {
    deque<int> dq;
    vector<int> result;
    
    for (int i = 0; i < nums.size(); i++) {
        while (!dq.empty() && dq.front() < i - k + 1) {
            dq.pop_front();
        }
        
        while (!dq.empty() && nums[dq.back()] < nums[i]) {
            dq.pop_back();
        }
        
        dq.push_back(i);
        
        if (i >= k - 1) {
            result.push_back(nums[dq.front()]);
        }
    }
    
    return result;
}`,
                        python: `from collections import deque

def maxSlidingWindow(nums, k):
    dq = deque()
    result = []
    
    for i, num in enumerate(nums):
        while dq and dq[0] < i - k + 1:
            dq.popleft()
        
        while dq and nums[dq[-1]] < num:
            dq.pop()
        
        dq.append(i)
        
        if i >= k - 1:
            result.append(nums[dq[0]])
    
    return result`,
                        java: `public int[] maxSlidingWindow(int[] nums, int k) {
    Deque<Integer> deque = new ArrayDeque<>();
    int[] result = new int[nums.length - k + 1];
    int idx = 0;
    
    for (int i = 0; i < nums.length; i++) {
        while (!deque.isEmpty() && deque.peekFirst() < i - k + 1) {
            deque.pollFirst();
        }
        
        while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) {
            deque.pollLast();
        }
        
        deque.offerLast(i);
        
        if (i >= k - 1) {
            result[idx++] = nums[deque.peekFirst()];
        }
    }
    
    return result;
}`
                    }
                }
            ],
            expert: [
                {
                    id: 'e1',
                    title: "Alien Dictionary",
                    difficulty: "expert",
                    problem: `There is a new alien language that uses the English alphabet. The order of the alphabet is unknown to you. You are given a list of strings words from the alien language's dictionary, where the strings are sorted lexicographically.

Return a string of the unique letters sorted in lexicographically increasing order by the alien language's rules. If there is no solution, return "".

Example:
Input: words = ["wrt","wrf","er","ett","rftt"]
Output: "wertf"`,
                    testCases: `Input: words = ["wrt","wrf","er","ett","rftt"]
Output: "wertf"

Input: words = ["z","x"]
Output: "zx"

Input: words = ["z","x","z"]
Output: ""`,
                    hint: "This is a topological sort problem. Build a graph of character dependencies, then use DFS or BFS to find ordering. Watch for cycles!",
                    solutions: {
                        cpp: `string alienOrder(vector<string>& words) {
    unordered_map<char, unordered_set<char>> graph;
    unordered_map<char, int> indegree;
    
    for (const string& word : words) {
        for (char c : word) {
            if (graph.find(c) == graph.end()) {
                graph[c] = unordered_set<char>();
                indegree[c] = 0;
            }
        }
    }
    
    for (int i = 0; i < words.size() - 1; i++) {
        string w1 = words[i], w2 = words[i + 1];
        
        if (w1.length() > w2.length() && w1.substr(0, w2.length()) == w2) {
            return "";
        }
        
        for (int j = 0; j < min(w1.length(), w2.length()); j++) {
            if (w1[j] != w2[j]) {
                if (graph[w1[j]].find(w2[j]) == graph[w1[j]].end()) {
                    graph[w1[j]].insert(w2[j]);
                    indegree[w2[j]]++;
                }
                break;
            }
        }
    }
    
    queue<char> q;
    for (auto& p : indegree) {
        if (p.second == 0) {
            q.push(p.first);
        }
    }
    
    string result;
    while (!q.empty()) {
        char c = q.front();
        q.pop();
        result += c;
        
        for (char neighbor : graph[c]) {
            indegree[neighbor]--;
            if (indegree[neighbor] == 0) {
                q.push(neighbor);
            }
        }
    }
    
    return result.length() == graph.size() ? result : "";
}`
                          }
                }
            ],
        };

        let currentChallenge = 0;
        let solvedCount = 0;
        let hintsUsed = 0;

        function showNextChallenge() {
            if (currentChallenge >= challenges.length) {
                document.querySelector('.next-challenge').innerHTML = 
                    '<h2 style="color: #2ecc71;">🎉 Congratulations! You\'ve completed all challenges!</h2>';
                return;
            }

            const challenge = challenges[currentChallenge];
            const challengeHtml = `
                <div class="challenge-card" id="challenge-${challenge.id}">
                    <div class="challenge-header">
                        <h2 class="challenge-title">${challenge.id}. ${challenge.title}</h2>
                        <span class="difficulty ${challenge.difficulty}">${challenge.difficulty.toUpperCase()}</span>
                    </div>
                    
                    <div class="problem-statement">
                        ${challenge.problem.replace(/\n/g, '<br>')}
                    </div>
                    
                    <div class="test-cases">
                        <strong>Test Cases:</strong>
                        <div class="code-block">${challenge.testCases}</div>
                    </div>
                    
                    <div class="button-group">
                        <button class="btn btn-primary" onclick="showHint(${challenge.id})">💡 Show Hint</button>
                        <button class="btn btn-secondary" onclick="showSolution(${challenge.id})">🔍 Show Solution</button>
                        <button class="btn btn-success" onclick="markSolved(${challenge.id})">✅ Mark as Solved</button>
                    </div>
                    
                    <div id="hint-${challenge.id}" class="hint hidden">
                        <strong>💡 Hint:</strong><br>
                        ${challenge.hint}
                    </div>
                    
                    <div id="solution-${challenge.id}" class="solution hidden">
                        <strong>🔍 Solution:</strong>
                        <div class="code-block">${challenge.solution}</div>
                    </div>
                </div>
            `;

            document.getElementById('challenges-container').insertAdjacentHTML('beforeend', challengeHtml);
            currentChallenge++;
            
            // Update button text
            const nextBtn = document.querySelector('.next-challenge button');
            if (currentChallenge < challenges.length) {
                nextBtn.textContent = `Next Challenge (${currentChallenge + 1}/${challenges.length})`;
            } else {
                nextBtn.textContent = 'All Challenges Loaded!';
                nextBtn.disabled = true;
                nextBtn.style.opacity = '0.5';
            }
        }

        function showHint(challengeId) {
            const hintEl = document.getElementById(`hint-${challengeId}`);
            hintEl.classList.remove('hidden');
            hintsUsed++;
            document.getElementById('hints-used').textContent = hintsUsed;
        }

        function showSolution(challengeId) {
            const solutionEl = document.getElementById(`solution-${challengeId}`);
            solutionEl.classList.remove('hidden');
        }

        function markSolved(challengeId) {
            const challengeCard = document.getElementById(`challenge-${challengeId}`);
            challengeCard.style.borderLeft = '5px solid #2ecc71';
            challengeCard.style.background = '#f8fff8';
            
            const button = challengeCard.querySelector('.btn-success');
            button.textContent = '✅ Solved!';
            button.disabled = true;
            button.style.opacity = '0.7';
            
            solvedCount++;
            document.getElementById('solved-count').textContent = solvedCount;
            
            // Update progress bar
            const progress = (solvedCount / challenges.length) * 100;
            document.getElementById('progress').style.width = progress + '%';
        }
    </script>
</body>
</html>